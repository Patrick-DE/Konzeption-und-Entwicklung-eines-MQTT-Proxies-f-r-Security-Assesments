\chapter{Validierung}
%Überprüfen der Thesen
%    Szenarien mit erwarteten Ergebnissen vergleichen
%    Ergebnisse über Prototyp bestätigen
    
Um bewerten zu können, ob das entwickelte Programm den genannten Anforderungen entspricht (siehe Kapitel 4), wird in diesem Kapitel zur Validierung ein virtualisiertes Labor aufgebaut, das einen virtuellen \ac{IoT}-Client, einen virtuellen Broker und den Proxy bereitstellt.

%Szenario, was mit dem Labor versucht wird zu erreichen.
Das Labor bildet die Kommunikation zwischen einem Sensor, welcher sich in der Glühbirne im Wohnzimmer des Nutzer befindet, und dem Broker des Herstellers ab. Der Sensor, im weiteren Client genannt, stellt dem Broker jede Sekunde den aktuelle Status zur Verfügung. Der Broker auf der anderen Seite erwartet den Status eines Clients und veröffentlicht diesen für andere externe Clients.

\begin{figure}[h]%h=direkt danach t=top b=bottom
    \centering
    \includegraphics[width=14cm]{tex/bilder/6_validierung/Szenario.pdf}
    \captionof{figure}{Darstellung des Szenarios}
    \label{fig:darstellung-szenario}
\end{figure}

\section{Laboraufbau}
    %Warum Virtualisierung/ Virtualisierte Umgebung
    Das Labor wird mithilfe der Virtualisierungslösung ESXi %\cite{https://www.vmware.com/de/products/esxi-and-esx.html}
    von VMware umgesetzt. Dadurch, dass alle Systeme und Applikationen in sogenannten Virtuellen Maschinen laufen, sind sie, obwohl sie auf dem gleichen Gerät (Server) laufen können, voneinander unabhängig. Das bedeutet, dass ganze Systeme abgeschottet und auf Virtuellen Festplatten (sog. \emph{\acp{VMDK}}) gespeichert und somit auch sehr einfach gesichert oder untereinander ausgetauscht werden können. Durch die dynamische Verteilung von zum Beispiel CPU oder RAM ist ebenfalls eine effektivere Nutzung von Hardwareressourcen möglich. Damit wird nur ein Server oder leistungsfähiger Computer benötigt um ganze Systemlandschaften und Netzwerke abzubilden. Des Weiteren ermöglicht es auch die hier durchgeführten Tests und somit Ergebnisse in der gleichen Umgebung durch die Bereitstellung der Dateien nachvollziehen zu können ohne selbst Arbeit und Zeit investieren zu müssen.
    %Warum mit ESXI
    ESXi wurde als Lösung gewählt, da bereits Wissen und Erfahrung im Umgang mit der Lösung vorhanden war. Zusätzlich stand ein Server mit benötigter Leistung bereits zur Verfügung wodurch das Aufsetzen und Konfigurieren eines solchen oder ähnlichen Produkts nicht mehr nötig machte.
    
    Die folgenden Voraussetzungen sind notwendig um das Programm ausführen zu können.
    \begin{itemize}
        \item Betriebssystem: ab Windows 7, Linux mit Mono
        \item Abhängigkeiten: .NET Framework v4.6.1, Mono ab 4.2.0.X
        \item Speicher: 50 MB frei
        \item RAM: 100 MB frei
        \item Prozessor: 2 virtuelle Kerne  mit 2,0 Ghz
        \item Netzwerkkarte: Ja
    \end{itemize}
    
    \subsection{Virtualisierung der Geräte}
    Die in diesem Szenario enthaltenen Systeme sind die Folgenden.
    \begin{table}[h]
        \centering
        \begin{tabular}{c|c|c|c}
            Name & Client & Broker & Proxy \\ \hline
            OS & Debian 9 & Debian 9 & Microsoft Windows 10 \\
            CPU & 1 vCPUs & 1 vCPUs & 4 vCPUs \\
            RAM & 512 MB & 512 MB & 8 GB \\
            HDD & 5 GB & 5 GB & 50 GB \\
        \end{tabular}
        \caption{Ressourcen der Virtuelle Maschinen}
        \label{tab:ressourcenverteilung}
    \end{table}
    
    Der Client verwendet folgende Software:
    \begin{itemize}
        \item Python 2.7.X
        \item pip-Paket: paho-mqtt
    \end{itemize}
            
    Der Broker arbeitet mithilfe folgender Software:
    \begin{itemize}
        \item Python 3.X, Python3-pip
        \item pip-Paket: hbmqtt
    \end{itemize}
            
    Das Proxy-System, welches die Kommunikation überwacht, benötigt zum Ausführen der Proxy-Anwendung folgende Software:
    \begin{itemize}
        \item Microsoft Visual C++ 2008
        \item Microsoft Visual C++ 2017
        \item .NET Framework 4.6.1
    \end{itemize}
    
    \subsection{Netwerk}
    Es wurden zwei Netzwerke verwendet in denen sich alle Geräte befunden haben. 
    Das erste Netzwerk beinhaltet den Audit PC, die Proxy Anwendung und den virtuellen Broker sowie die Firewall als Schnittstelle zum zweiten Netzwerk.
    Die Firewall spannt ein \ac{VLAN} auf, in dem sich der Client befindet. Mittels Portweiterleitung\footnote{Pakete, die den spezifizierten Port beinhalten, werden an ein festgelegte Adresse weitergeleitet.} leitet es den Datenverkehr des Clients zum Proxy um. %TODO FRAGEN OB QUELLE NOTWENDIG
    
    \begin{figure}[h]%h=direkt danach t=top b=bottom
        \centering
        \includegraphics[width=14cm]{tex/bilder/6_validierung/Netzwerkdiagramm.pdf}
        \captionof{figure}{Darstellung des virtuellen Netzwerks}
        \label{fig:virtuelles_netzwerk}
    \end{figure}
    
    \subsection{Konfiguration der Software}
    %Konfiguration
    Das Projekt ist im Standard auf x86 Prozessoren ausgerichtet, kann allerdings bei Bedarf auch auf x64 Prozessoren durch Änderung der entsprechenden Einstellung in \ac{VS} geändert werden.
    Eine Unterstützung für weitere Architekturen ist durch die plattformübergreifende Implementierungen von Mono und Python möglich.
    Zusätzlich ist bei Ausführung der Anwendung ein privilegierter Account erforderlich um die Berichtigung für Zugriff auf die erforderlichen Ports zu erhalten.
    Es werden Port 1883 für die Kommunikation über das \ac{MQTT}-Protokoll und Port 80 für die \ac{REST} Schnittstelle und einen Webserver, der die Weboberfläche bereitstellt, benötigt.
    Der Proxy ist ausschließlich über die Adresse \glqq 127.0.0.1\grqq{} oder \glqq localhost\grqq{} erreichbar, da keine Benutzerauthentifizierung implementiert wurde. Im lokalen Netz oder bei Bereitstellung über eine öffentlich erreichbare Adresse, kann eine unberechtigte Verwendung nicht ausgeschlossen werden. Daher wird die Änderung auch nicht empfohlen. Sofern jedoch die Notwendigkeit bestehen sollte, ist es möglich die Adresse im Quellcode, durch die lokale IP-Adresse des Gerätes auf dem der Proxy läuft, auszutauschen, um eine parallele oder externe Verwendung zu ermöglichen.
    
\section{Ausführung und Bewertung}
Auf Abbildung \ref{fig:client_messages} ist der erstellte virtuelle Client zu sehen, welcher Nachrichten über den Proxy an den Broker schickt.
%Was für Nachrichten
%Was passiert danach
\begin{figure}[!h]%h=direkt danach t=top b=bottom
    \centering
    \includegraphics[width=10cm]{tex/bilder/6_validierung/ClientMessages.png}
    \captionof{figure}{Darstellung des gesendeten Nachrichten vom Client}
    \label{fig:client_messages}
\end{figure}

Broker Verbindungen
\begin{figure}[!h]%h=direkt danach t=top b=bottom
    \centering
    \includegraphics[width=14cm]{tex/bilder/6_validierung/BrokerConnections.png}
    \captionof{figure}{Darstellung der Client-Verbindungen beim Broker}
    \label{fig:broker_connections}
\end{figure}

Proxy Messages
\begin{figure}[!h]%h=direkt danach t=top b=bottom
    \centering
    \includegraphics[width=12cm]{tex/bilder/6_validierung/ProxyMessages.png}
    \captionof{figure}{Darstellung der Nachrichten verarbeitet vom Proxy}
    \label{fig:proxy_messages}
\end{figure}

Frontend Interceptor
\begin{figure}[!h]%h=direkt danach t=top b=bottom
    \centering
    \includegraphics[width=14cm]{tex/bilder/6_validierung/FrontendInterceptor.png}
    \captionof{figure}{Darstellung der Nachrichten im Frontend}
    \label{fig:frontend_messages}
\end{figure}

Was wird ausgeführt, welche Tests
Als erstes mit einem Client
    Intercepten: werden keine neuen rausgeschickt? werden sie im Web angezeigt?
    Modifizieren: können die im Web modifiziert werden?
    Speichern von Änderungen: können nach der Mod die auch gespeichert werden?
    Neue Nachrichten schicken: können neue geschickt werden?
Als zweites mit zwei Clients

\section{Performance}
    Hier wird die Performance des Proxys analysiert um Hinweise auf Skalierbarkeit und notwendige Ressourcen zu erhalten.
    Folgende Performance-Werte wurden mithilfe des Visual Studio Profilers auf der \ac{VM} Proxy erfasst.
    
    \begin{enumerate}
        \item Ohne Clients:
        Solange das Programm im Leerlauf arbeitet, also nur Events registriert sind die auf die Einwirkung anderer Komponenten warten, benötigt das Programm 19 MB \ac{RAM} und hat eine maximale CPU Auslastung von 1 Prozent.
        \item Mit einem Client:
        Sobald der erste Client sich verbunden hat, wir nur 1 MB mehr \ac{RAM} benötigt, was auf ein Gesamt von 20 MB kommt. Im Gegensatz dazu werden nun nach der ankommenden Nachricht vom \ac{IoT}-Client alle Funktionen des Programms ausgeführt. Dies führt zu einer Erhöhung beim Ausführen der Connect Funktion auf 20 Prozent und anschießend maximal 17 Prozent.
        \item Mit zwei Clients:
        Kommt nun ein weiterer Client dazu, sodass nun zwei Clients mit dem Proxy verbunden sind, steigt der \ac{RAM} Verbrauch weiterhin nur um 1 Prozent auf 21 MB an. Die maximale CPU Auslastung steigt jedoch auf 33 Prozent, was eine Steigerung um 95 Prozent darstellt. Dies ist unter anderem auf ein aktuelles Problem %\cite{https://github.com/Patrick-DE/MQTT-Proxy/issues/3}
        zurückzuführen was dazu führt, dass jeder Client die Antworten aller Clients an den Proxy schickt. Dies bedeutet, dass Antworten des externen Brokers doppelt erfasst und publiziert werden.
        Bei genauerer Analyse beider, am Anstiegen beteiligten Funktionen, ist zu erkennen, dass der größte Ressourcenverbrauch bei den folgenden Funktionen ist.
        \begin{itemize}
            \item Für 30 Prozent der maximalen CPU Auslastung des Programms ist die Connect Funktion verantwortlich. Die Connect Funktion wird aufgerufen, sobald sich ein \ac{IoT}-Client bei dem Proxy registriert. Sie hat mehrere Abhängigkeiten zu weiteren Funktionen die die Methode aufwändiger macht.  
            \item Für 57 Prozent der maximalen CPU Auslastung des Programms ist die Systemfunktion Console.WriteLine() Funktion verantwortlich. Da in diesem Programm viele Informationen an die Konsolenoberfläche zur Information an den Entwickler oder Nutzer weitergereicht werden ist dies die Hauptursache, dass das Programm die oben genannten CPU Auslastung aufweist. Zu bemerken ist jedoch, dass diese nur den maximalen Wert anzeigen, welcher nur vorhanden ist, wenn Nachrichten an den externen Broker weitergeleitet werden.
        \end{itemize}
    \end{enumerate}